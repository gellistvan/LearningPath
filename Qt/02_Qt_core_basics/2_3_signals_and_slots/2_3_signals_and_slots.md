

### 2.3: Event Loop and Signal & Slots

The event loop is a core part of Qt applications, handling all events from the window system and other sources. Signals and slots are used for communication between objects and can cross thread boundaries.

**Key Concepts:**

* `QEventLoop`: Manages a loop that processes events.
* `signals`: Methods that are declared but not deﬁned.
* `slots`: Methods that can be called in response to signals.

#### QEventLoop
The `QEventLoop` is a crucial part of the Qt framework that manages an event loop within a Qt application. An event loop is a programming construct that waits for and dispatches events or messages in a program. It's an integral part of any Qt application because it handles all events from the window system and other sources, such as timers and network sockets.
In a typical Qt application, the event loop is started using the `exec()` method of a `QEventLoop` or `QApplication` object. This loop continues running until `exit()` is called on the respective object, processing incoming events and ensuring that your application remains responsive. The `QEventLoop` can be used to create local event loops in specific parts of your application, which can be useful for handling tasks that require a focused, uninterrupted sequence of operations while still processing events.

#### Signals and Slots
Signals and slots are a mechanism in Qt used for communication between objects and are one of the key features of Qt's event-driven architecture. They make it easy to implement the Observer pattern while avoiding boilerplate code.

**Signals**
In Qt, a signal is a method that is declared but not defined by the programmer. Instead, it is automatically generated by the Meta-Object Compiler (MOC). Signals are used to announce that a specific event has occurred. For example, a button widget might emit a `clicked()` signal when it is pressed. Here's an example of declaring a signal in a class:
```
class MyClass : public QObject {
	Q_OBJECT
public:
	MyClass() {}
signals:
	void mySignal();
};
```
In the above example, `mySignal()` is a signal. You do not provide a definition for this method—the MOC takes care of that.

**Slots**
A slot is a normal C++ method that can be connected to one or more signals. When a signal connected to a slot is emitted, the slot is automatically invoked by the Qt framework. This allows for a very flexible communication mechanism between different parts of your application. Here's how you might define a class with a slot:

```
class MyClass : public QObject {
	Q_OBJECT
public slots:
	void mySlot() {
		// Your code here
	}
};
```

To connect a signal to a slot, Qt provides the `connect()` method, which can link signals from any object to slots of any other (or the same) object. For example:

```
MyClass obj;
QPushButton button;
QObject::connect(&button, &QPushButton::clicked, &obj, &MyClass::mySlot);
```
In this example, clicking the button would automatically call `mySlot()` on `obj`.


**Example 1**: A simple timer that uses signals and slots.
```
#include <QTimer>
#include <QCoreApplication>
#include <QDebug> 
 
class Timer : public QObject { 
    Q_OBJECT 
public slots: 
    void handleTimeout() { qDebug() << "Timeout occurred"; } 
}; 
 
int main(int argc, char *argv[]) { 
    QCoreApplication app(argc, argv); 
    QTimer timer; 
    Timer t; 
    QObject::connect(&timer, &QTimer::timeout, &t, &Timer::handleTimeout); 
    timer.start(1000);  // 1000 milliseconds 
    return app.exec(); 
}
```

**Example 2**: Advanced signal-slot connection:

```
#include <QObject>
#include <QTimer>
#include <QDebug> 
 
class Worker : public QObject { 
    Q_OBJECT 
public slots: 
    void process() { 
        qDebug() << "Processing..."; 
        emit finished(); 
    } 
signals: 
    void finished(); 
}; 
 
int main(int argc, char *argv[]) { 
    QCoreApplication app(argc, argv); 
    QTimer timer; 
    Worker worker; 
    QObject::connect(&timer, &QTimer::timeout, &worker, &Worker::process); 
    QObject::connect(&worker, &Worker::finished, &app, &QCoreApplication::quit); 
    timer.start(1000); 
    return app.exec(); 
} 
```